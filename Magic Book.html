<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8" /> <title> Peak &amp; Valley Detector — User Manual</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <style> :root{ --ink:#0f172a; --muted:#475569; --accent:#ef7d00; --bg:#fffaf3; --line:#e2e8f0; } *{box-sizing:border-box} body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink);line-height:1.55;margin:0;background:#fff} header{background:var(--bg);border-bottom:1px solid var(--line);padding:28px 20px} h1{margin:0 0 6px;font-size:28px} h2{margin:28px 0 12px;font-size:22px} h3{margin:22px 0 8px;font-size:18px} h4{margin:16px 0 6px;font-size:16px} p{margin:10px 0} code,.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#f8fafc;border:1px solid var(--line);border-radius:6px;padding:0 4px} .note,.tip,.warn{border-left:4px solid;padding:12px 14px;background:#f8fafc;margin:14px 0;border-radius:6px} .note{border-color:#94a3b8} .tip{border-color:#10b981;background:#f0fdf4} .warn{border-color:#f59e0b;background:#fffbeb} .grid{display:grid;gap:14px} @media (min-width:960px){.grid.cols-2{grid-template-columns:1fr 1fr}} table{border-collapse:collapse;width:100%;margin:12px 0} th,td{border:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:top} th{background:#f8fafc} .panel{border:1px solid var(--line);border-radius:10px;padding:12px 14px;background:#fff} .panel h4{margin-top:0} .kbd{padding:2px 6px;border-radius:4px} .small{color:var(--muted);font-size:12px} .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#fff1e6;border:1px solid #ffd7b3;color:#6b3b00;font-size:12px;margin-left:6px} .list-tight li{margin:6px 0} .hr{border-top:1px dashed var(--line);margin:18px 0} main{padding:22px 20px;max-width:1080px;margin:0 auto} nav ul{list-style:none;padding:0;margin:0;display:flex;flex-wrap:wrap;gap:6px} nav a{display:inline-block;padding:6px 10px;border:1px solid var(--line);border-radius:999px;text-decoration:none;color:var(--ink)} nav a:hover{border-color:var(--accent)} section{scroll-margin-top:80px} caption{caption-side:top;text-align:left;font-weight:600;margin-bottom:6px} </style> </head> <body> <header> <h1>Peak&nbsp;&amp;&nbsp;Valley Detector User Manual</h1> <p class="small">A practical, step-by-step guide to using the Streamlit interface.</p> <div class="warn"><strong>Heads-up:</strong> Refreshing or closing the page clears all uploaded data and results. Download what you need before you leave.</div> </header> <main role="main"> <nav aria-label="On this page"> <ul> <li><a href="#overview">Overview</a></li> <li><a href="#quickstart">Quick Start</a></li> <li><a href="#controls">Controls</a></li> <li><a href="#per-sample">Per-sample Tuning</a></li> <li><a href="#alignment">Alignment</a></li> <li><a href="#outputs">Outputs</a></li> <li><a href="#recipes">Quick Recipes</a></li> <li><a href="#gpt">GPT Helper</a></li> <li><a href="#lifecycle">Run Lifecycle</a></li> </ul> </nav>

    <section id="overview" aria-labelledby="overview-heading">
  <h2 id="overview-heading">What this app does (in one breath)</h2>
  <p>It reads single-marker counts (as CSVs or from your full dataset), applies an <em>arcsinh</em> transform, fits KDE curves, finds peaks &amp; valleys, scores stain quality, lets you tweak per sample, and (optionally) aligns landmarks across samples before exporting plots and CSVs.</p>

  <div class="grid cols-2">
    <div class="note" role="note">
      <strong>Two workflows</strong>
      <ol class="list-tight">
        <li><strong>Counts CSV files</strong> — upload files named like <code>*_raw_counts.csv</code>.</li>
        <li><strong>Whole dataset</strong> — upload <code>expression_matrix_combined.csv</code> and <code>cell_metadata_combined.csv</code>; select markers/samples; generate counts.</li>
      </ol>
    </div>
    <div class="tip" role="note">
      <strong>Incremental engine</strong><br>
      Files are processed one-by-one; you’ll see live plots and a progress bar. You can <span class="kbd">Pause</span> and <span class="kbd">Resume</span> mid-run.
    </div>
  </div>
</section>

<section id="quickstart" aria-labelledby="quickstart-heading">
  <h2 id="quickstart-heading">Quick Start</h2>

  <h3>Path A — Counts CSV files</h3>
  <ol class="list-tight">
    <li>In the sidebar, choose <strong>Counts CSV files</strong>.</li>
    <li><strong>Upload</strong> your <code>_raw_counts.csv</code> files and select which to use.</li>
    <li>Set <strong>Header row</strong> (e.g., <code>-1</code> for no header) and <strong>Rows to skip</strong> if needed.</li>
    <li>Pick detection settings (see “Controls” below), then click <strong>Run detector</strong>.</li>
    <li>Inspect results under <strong>Processed datasets</strong> → <em>Plot</em> / <em>Parameters</em> / <em>Manual</em>.</li>
  </ol>
  <p><img src="images/countsCSV.png" alt="Counts CSV workflow" style="max-width:100%;"></p>

  <h3>Path B — Whole dataset</h3>
  <ol class="list-tight">
    <li>In the sidebar, choose <strong>Whole dataset</strong>.</li>
    <li>Upload <code>expression_matrix_combined.csv</code> and <code>cell_metadata_combined.csv</code>.</li>
    <li>(Optional) Filter by <strong>batch</strong>. Then select <strong>Marker(s)</strong> and <strong>Sample(s)</strong>.</li>
    <li>Click <strong>Generate counts CSVs</strong> to cache per-sample counts. You can switch to <strong>Counts CSV files</strong> or just hit <strong>Run detector</strong> (it auto-uses the generated counts).</li>
  </ol>
  <p><img src="images/WholeDataset.png" alt="Whole dataset workflow" style="max-width:100%;"></p>

  <div class="note" role="note">
    <strong>Expected columns</strong>
    <ul class="list-tight">
      <li><code>expression_matrix_combined.csv</code>: one column per marker; often a <code>cell_id</code> column (it’s ignored).</li>
      <li><code>cell_metadata_combined.csv</code>: must include <code>sample</code>; <code>batch</code> is optional but useful.</li>
    </ul>
  </div>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="controls" aria-labelledby="controls-heading">
  <h2 id="controls-heading">Controls and when to adjust them</h2>
  <p class="small">The table shows what each control does and how to tune it for typical data patterns.</p>

  <table aria-describedby="controls-desc">
    <caption id="controls-desc">Controls, effects, and tuning guidance</caption>
    <thead>
      <tr>
        <th scope="col">Control</th>
        <th scope="col">Screenshot</th>
        <th scope="col">What it does</th>
        <th scope="col">When to increase / decrease</th>
        <th scope="col">Practical tips</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Number of peaks</strong><br><code>Number of peaks</code> (fixed 1–6 or “GPT Automatic”)<span class="pill">Key</span></td>
        <td><img src="images/numberPeaks.png" alt="Number of peaks" style="max-width:100%;"><br><img src="images/maxPeaks.png" alt="Maximum peaks" style="max-width:100%;"></td>
        <td>How many peaks to target. In GPT mode, the model estimates up to <em>Maximum peaks</em>.</td>
        <td><strong>Increase</strong> if you clearly see separate subpopulations.<br><strong>Decrease</strong> if peaks are being split by noise.</td>
        <td>Set a realistic <em>Maximum peaks</em> cap (e.g., 3–4) so auto-mode doesn’t over-segment.</td>
      </tr>
      <tr>
        <td><strong>Bandwidth</strong><br><code>Bandwidth mode</code> → Manual (“scott”, “silverman”, or numeric 0.5–1.0) or GPT</td>
        <td><img src="images/bandwidth.png" alt="Bandwidth" style="max-width:100%;"></td>
        <td>KDE smoothness. Larger bandwidth → smoother curve; smaller → more detail.</td>
        <td><strong>Increase</strong> for noisy, jagged histograms (e.g., tiny n, many zeroes).<br><strong>Decrease</strong> to separate close peaks.</td>
        <td><code>scott</code> = robust default; <code>silverman</code> slightly smoother. Numeric like <code>0.8</code> or <code>1.0</code> applies a scale factor.</td>
      </tr>
      <tr>
        <td><strong>Prominence</strong><br><code>Prominence</code> (0.00–0.30) or GPT</td>
        <td><img src="images/prominence.png" alt="Prominence" style="max-width:100%;"></td>
        <td>How tall a candidate peak must be above surroundings.</td>
        <td><strong>Increase</strong> to suppress tiny ripples / background.<br><strong>Decrease</strong> to keep shallow shoulders in heterogeneous samples.</td>
        <td>Start around <code>0.05</code>. If you lose a known small peak, step down to <code>0.03</code>.</td>
      </tr>
      <tr>
        <td><strong>Minimum peak width</strong><br><code>Min peak width</code> (0–6)</td>
        <td><img src="images/minPeakWidth.png" alt="Minimum peak width" style="max-width:100%;"></td>
        <td>Rejects peaks narrower than this width (KDE grid units).</td>
        <td><strong>Increase</strong> to remove needle-like false positives.<br><strong>Decrease</strong> to allow sharp, narrow peaks.</td>
        <td>Try <code>1–2</code> for spiky data; keep <code>0</code> if genuine peaks are tight.</td>
      </tr>
      <tr>
        <td><strong>Curvature threshold</strong><br><code>Curvature thresh</code> (0 = off)</td>
        <td><img src="images/curvature.png" alt="Curvature threshold" style="max-width:100%;"></td>
        <td>Filters out peaks with too-flat curvature near the top.</td>
        <td><strong>Increase</strong> to avoid broad, flat plateaus being mis-called.<br><strong>Decrease</strong> (toward <code>0</code>) for flat-topped biology that’s still meaningful.</td>
        <td>Small but non-zero (<code>0.0001–0.001</code>) often stabilizes calls.</td>
      </tr>
      <tr>
        <td><strong>Turning points as peaks</strong><br><code>Treat concave-down turning points as peaks</code></td>
        <td><img src="images/turningPoint.png" alt="Turning points as peaks" style="max-width:100%;"></td>
        <td>Allows shoulders/inflections to count as peaks.</td>
        <td>Turn <strong>on</strong> for plateau + shoulder shapes.<br>Turn <strong>off</strong> if it over-splits broad peaks.</td>
        <td>Pairs well with a slightly higher <em>Min peak width</em> to avoid tiny shoulders.</td>
      </tr>
      <tr>
        <td><strong>Minimum peak separation</strong><br><code>Min peak separation</code></td>
        <td><img src="images/minPeakSep.png" alt="Minimum peak separation" style="max-width:100%;"></td>
        <td>Forbids peaks closer than this distance (data units).</td>
        <td><strong>Increase</strong> to merge twins into a single broad peak.<br><strong>Decrease</strong> to allow very close doublets.</td>
        <td>If two true peaks keep merging, lower separation and slightly lower bandwidth.</td>
      </tr>
      <tr>
        <td><strong>Max KDE grid</strong><br><code>Max KDE grid</code> (4k–40k)</td>
        <td><img src="images/maxKDE.png" alt="Max KDE grid" style="max-width:100%;"></td>
        <td>Resolution of the KDE x-grid.</td>
        <td><strong>Increase</strong> for fine detail on tightly packed peaks.<br><strong>Decrease</strong> to speed up large runs.</td>
        <td><code>20,000</code> is a good default; go <code>≥30,000</code> for ultra-close peaks.</td>
      </tr>
      <tr>
        <td><strong>Valley drop</strong><br><code>Valley drop (% of peak)</code></td>
        <td><img src="images/ValleyDrop.png" alt="Valley drop" style="max-width:100%;"></td>
        <td>For single-peak cases, forces a valley where the curve falls to X% of the peak height (to the right).</td>
        <td><strong>Increase</strong> (e.g., 20–30%) if a tail never dips low enough to mark a valley.<br><strong>Decrease</strong> to demand a deeper dip.</td>
        <td>Useful for gating downstream even when only one clear mode exists.</td>
      </tr>
      <tr>
        <td><strong>Marker consistency</strong><br><code>Enforce marker consistency across samples</code></td>
        <td><img src="images/consistency.png" alt="Marker consistency" style="max-width:100%;"></td>
        <td>Harmonizes peak/valley counts and ordering for the same marker across samples after all files finish.</td>
        <td>Keep <strong>on</strong> when you compare samples; turn <strong>off</strong> for unrelated markers or exploratory runs.</td>
        <td>After harmonization, per-sample plots update to reflect the consistent set.</td>
      </tr>
    </tbody>
  </table>

  <h3>Choosing auto (GPT) vs manual</h3>
  <ul class="list-tight">
    <li>Use <strong>GPT Automatic</strong> when you have an API key and heterogeneous patterns across files (it adapts per sample).</li>
    <li>Use <strong>manual</strong> when you want deterministic settings across a cohort (publication, reproducibility) or no API key.</li>
  </ul>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="per-sample" aria-labelledby="per-sample-heading">
  <h2 id="per-sample-heading">Per-sample tuning</h2>

  <div class="grid cols-2">
      <div class="panel">
      <h4>Parameters tab (per-sample overrides)</h4>
      <img src="images/parameters.png" alt="Parameters tab" style="max-width:100%;">
      <ul class="list-tight">
        <li>Choose <em>Preset</em> vs <em>Numeric</em> for bandwidth, set <em>Prominence</em>, and <em># peaks</em>.</li>
        <li>Any change marks the sample <em>dirty</em>; the next <strong>Run detector</strong> re-processes it with your overrides.</li>
      </ul>
    </div>
      <div class="panel">
      <h4>Manual tab (drag &amp; drop markers)</h4>
      <img src="images/manual.png" alt="Manual tab" style="max-width:100%;">
      <ul class="list-tight">
        <li>Move existing <strong>Peak</strong> and <strong>Valley</strong> sliders; <em>Add</em> or <em>Delete</em>.</li>
        <li>Click <strong>Apply changes</strong> to finalize and refresh ridge plots.</li>
      </ul>
    </div>
  </div>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="alignment" aria-labelledby="alignment-heading">
  <h2 id="alignment-heading">Alignment &amp; normalization (cross-sample harmonization)</h2>
  <p><img src="images/AlignmentParameters.png" alt="Alignment parameters" style="max-width:100%;"></p>
  <ol class="list-tight">
    <li>Pick a <strong>Landmark set</strong>:
      <ul class="list-tight">
        <li><code>negPeak</code> — align the negative (unstained) peak only.</li>
        <li><code>valley</code> — align by the valley (useful for gating thresholds).</li>
        <li><code>negPeak_valley</code> — stabilize background and threshold simultaneously.</li>
        <li><code>negPeak_valley_posPeak</code> — full anchor (background, threshold, positive mode).</li>
      </ul>
    </li>
    <li>Choose <strong>Target positions</strong>:
      <ul class="list-tight">
        <li><em>Automatic</em> — uses the median landmark positions across samples.</li>
        <li><em>Custom</em> — type exact numeric targets (defaults shown when selected: e.g., 2.0, 3.0, 5.0).</li>
      </ul>
    </li>
    <li>Click <strong>Align landmarks &amp; normalize counts</strong>.<br><img src="images/alignmentButton.png" alt="Align button" style="max-width:100%;"></li>
    <li>Review <em>Aligned</em> per-sample plots and the stacked ridge under <strong>Comparison</strong> (<em>Raw</em> vs <em>Aligned</em>).</li>
    <li>Export <strong>alignedData.zip</strong> (aligned counts per sample, aligned per-sample PNGs, aligned ridge, and <code>aligned_summary.csv</code>).</li>
  </ol>

  <div class="tip" role="note">
    <strong>When to align</strong><br>
    Use alignment if batches shift modes (e.g., background drift) or you need a common gate across samples. If your samples already coincide well, skip it.
  </div>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="outputs" aria-labelledby="outputs-heading">
  <h2 id="outputs-heading">Outputs &amp; where to find them</h2>
  <p><img src="images/output.png" alt="Outputs" style="max-width:100%;"></p>
  <ul class="list-tight">
    <li><strong>Processed datasets</strong> → <em>Plot</em>: per-sample KDE with peak (dashed) and valley (dotted) markers; <em>Parameters</em>: the values used; <em>Manual</em>: editor.</li>
    <li><strong>Summary ∣ downloads</strong> tab:
      <ul class="list-tight">
        <li><strong>summary.csv</strong> (file, peaks, valleys, quality).</li>
        <li><strong>SampleCurves.zip</strong> — per-sample <code>xs</code>/<code>ys</code> CSVs of the KDE curves.</li>
        <li><strong>StainQuality.csv</strong> — file vs quality score.</li>
        <li><strong>Aligned Data</strong> (if you aligned): everything aligned + <code>aligned_summary.csv</code>.</li>
      </ul>
    </li>
    <li><strong>Quality</strong> tab: bar chart of stain-quality scores (higher ≈ cleaner separation / contrast).</li>
    <li><strong>Comparison</strong> tab: stacked ridge plots (<em>Raw</em> vs <em>Aligned</em>).</li>
    <li>Top-level <strong>PeakValleyResults.zip</strong>: <code>summary.csv</code> + all per-sample PNGs.</li>
  </ul>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="recipes" aria-labelledby="recipes-heading">
  <h2 id="recipes-heading">Quick recipes (set combos for common shapes)</h2>

  <table aria-describedby="recipes-desc">
    <caption id="recipes-desc">Recommended parameter sets for common patterns</caption>
    <thead>
      <tr>
        <th scope="col">Pattern</th>
        <th scope="col">Suggested settings</th>
        <th scope="col">Why</th>
        <th scope="col">Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Noisy, jagged histogram (low n)</td>
        <td>Bandwidth: <code>silverman</code> or <code>1.0</code><br>Prominence: <code>0.07–0.12</code><br>Min width: <code>1–2</code><br>Curvature: <code>0.0005</code></td>
        <td>Smooths noise, rejects needle peaks, requires clearer bumps.</td>
        <td><img src="images/jagged.png" alt="Jagged histogram example" style="max-width:120px;"></td>
      </tr>
      <tr>
        <td>Two peaks very close</td>
        <td>Bandwidth: <code>0.5–0.8</code><br>Prominence: <code>0.03–0.06</code><br>Min separation: slightly <em>lower</em> than default<br>Grid: <code>≥ 30,000</code></td>
        <td>Sharper KDE + tighter separation + finer grid resolves the doublet.</td>
        <td><img src="images/closePeaks.png" alt="Two close peaks example" style="max-width:120px;"></td>
      </tr>
      <tr>
        <td>Broad plateau with a shoulder</td>
        <td>Turn on <em>Turning points as peaks</em><br>Curvature: small (<code>0.0001</code>) or <code>0</code><br>Min width: <code>1</code></td>
        <td>Treats the shoulder as a real peak; avoids filtering flat tops.</td>
        <td><img src="images/shoulderPeak.png" alt="Shoulder peak example" style="max-width:120px;"></td>
      </tr>
      <tr>
        <td>Long right tail, single clear peak</td>
        <td>Bandwidth: <code>scott</code> or <code>silverman</code><br>Valley drop: <code>20–30%</code></td>
        <td>Forces a reasonable valley along the tail for downstream gating.</td>
        <td><img src="images/onePeak.png" alt="Single peak example" style="max-width:120px;"></td>
      </tr>
      <tr>
        <td>Over-segmentation (too many peaks)</td>
        <td>Lower <em>Maximum peaks</em> or fix <em># peaks</em><br>Bandwidth: nudge up (e.g., <code>0.8–1.0</code>)<br>Prominence: nudge up (e.g., <code>0.06–0.1</code>)<br>Min separation: nudge up</td>
        <td>Suppresses minor ripples and merges spurious splits.</td>
        <td><img src="images/manyPeaks.png" alt="Many peaks example" style="max-width:120px;"></td>
      </tr>
      <tr>
        <td>Under-segmentation (merging distinct peaks)</td>
        <td>Bandwidth: nudge down (e.g., <code>0.5–0.7</code>)<br>Prominence: nudge down (<code>0.03–0.05</code>)<br>Min separation: nudge down<br>Grid: increase</td>
        <td>Restores resolution and allows closer peaks to appear.</td>
        <td><img src="images/lessPeaks.png" alt="Few peaks example" style="max-width:120px;"></td>
      </tr>
    </tbody>
  </table>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="gpt" aria-labelledby="gpt-heading">
  <h2 id="gpt-heading">Using the GPT helper (optional)</h2>
  <p><img src="images/gpt.png" alt="GPT helper" style="max-width:100%;"></p>
  <ul class="list-tight">
    <li>Pick a <strong>Model</strong> (e.g., <code>o4-mini</code>, <code>gpt-4o-mini</code>, <code>gpt-4-turbo-preview</code>, or <em>Custom</em>), and paste your <strong>OpenAI API key</strong>.</li>
    <li>Enable “GPT automatic” for <em>Number of peaks</em>, <em>Bandwidth</em>, and/or <em>Prominence</em>.</li>
    <li>If no key is provided, GPT features are disabled; the app falls back to your manual settings (and robust heuristics for peak count).</li>
  </ul>

  <div class="hr" aria-hidden="true"></div>
</section>

<section id="lifecycle" aria-labelledby="lifecycle-heading">
  <h2 id="lifecycle-heading">Run lifecycle, pausing, and clearing</h2>
  <p><img src="images/lifecycle.png" alt="Run lifecycle" style="max-width:100%;"></p>
  <ul class="list-tight">
    <li><strong>Run detector</strong> queues unprocessed or “dirty” files and processes them one-by-one.</li>
    <li><strong>Pause / Resume</strong> toggles mid-batch; progress bar shows <em>done/total</em>.</li>
    <li><strong>Clear results</strong> wipes results, plots, parameters, alignment artifacts, and queue (but not your cached uploads).</li>
    <li>Cached uploads/dataset: clear them in the sidebar (<em>Clear cached uploads</em> / <em>Clear loaded dataset</em>).</li>
  </ul>

  <div class="hr" aria-hidden="true"></div>
  </section>

</main> </body> </html>
